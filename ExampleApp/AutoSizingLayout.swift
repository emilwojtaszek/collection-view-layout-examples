//
//  AutoSizingLayout.swift
//  ExampleApp
//
//  Created by Emil Wojtaszek on 12/02/2017.
//  Copyright Â© 2017 AppUnite Sp. z o.o. All rights reserved.
//

import UIKit

class AutoSizingLayout: UICollectionViewLayout {
    
    /// struct of layout constants
    private struct Constants {
        struct Footer {
            static let kind = "footer"
            static let height: CGFloat = 140.0
            static let indexPath = IndexPath(item: 1, section: 0)
        }
    }
    
    /// cells attributes
    private var currentAttributes: [LayoutAttributes] = []

    /// footer layout attributes
    private var footerLayoutAttributes: LayoutAttributes?
    
    // start values
    var estimatedItemHeight: CGFloat = 57.0
    
    /// cached sizes (result of autolayout)
    private var cachedSizes: [IndexPath: CGSize] = [:]
    
    required public override init() {
        super.init()
        self.registerDecorationView()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        self.registerDecorationView()
    }
    
    override class var layoutAttributesClass: AnyClass {
        return LayoutAttributes.self
    }
    
    /// MARK: - Preparation
    
    override func prepare() {
        super.prepare()

        //
        prepareContentCellAttributes()
    }
    
    private func prepareContentCellAttributes() {
        // for simplicity supports only one section with multiple cells
        guard let collectionView = collectionView else { return }
        assert(collectionView.numberOfSections == 1, "This layout supports only one section")

        // reset
        currentAttributes = []

        //
        var origin: CGFloat = 0
        let width = collectionView.bounds.size.width
        let itemCount = collectionView.numberOfItems(inSection: 0)

        //
        for itemIndex in 0..<itemCount {
            // create attributes
            let indexPath = IndexPath(item: itemIndex, section: 0)
            let attributes = LayoutAttributes(forCellWith: indexPath)
            
            // in our case preferred width is width of collection view
            attributes.preferredWidth = collectionView.frame.width
            
            // use cache value (generated by auto-layout), or generate size with estimated height
            let size = cachedSizes[indexPath] ?? CGSize(width: width, height: estimatedItemHeight)
            attributes.frame = CGRect(origin: CGPoint(x: 0.0, y: origin), size: size)
            
            // collect attributes
            currentAttributes.append(attributes)

            // move cursor
            origin += size.height
        }

        // update content size
        contentSize = CGSize(width: width, height: origin)
    }

    private func prepareFooterViewAttributes() {
        guard let collectionView = collectionView else { return }
        
        // create attributes for footer decoration view
        footerLayoutAttributes = LayoutAttributes(
            forDecorationViewOfKind: Constants.Footer.kind,
            with: Constants.Footer.indexPath
        )
        
        // put it below other content
        footerLayoutAttributes!.zIndex = -1
        
        // calculate size (put at the end of content and stick to bottom edge)
        let height = max(0, collectionView.contentOffset.y + collectionView.frame.height - contentSize.height - collectionView.contentInset.bottom)
        let size = CGSize(width: collectionView.frame.width, height: max(Constants.Footer.height, height))
        let origin = CGPoint(x: 0.0, y: contentSize.height)
        footerLayoutAttributes!.frame = CGRect(origin: origin, size: size)
        
        //
        let factor = height / Constants.Footer.height
        footerLayoutAttributes!.alpha = min(max(factor, 0.0), 1.0)
    }
    
    /// MARK: - Layout Attributes - Content Cell
    
    override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
        var attributes: [UICollectionViewLayoutAttributes] = []

        // display visible items
        for item in currentAttributes where rect.intersects(item.frame) {
            attributes.append(item)
        }

        // display footer is visible
        if let attr = footerLayoutAttributes {
            if rect.intersects(attr.frame) {
                attributes.append(attr)
            }
        }
        
        return attributes
    }
    
    override func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
        return currentAttributes[indexPath.row]
    }
    
    /// MARK: - Layout Attributes - Decoration View

    override public func layoutAttributesForDecorationView(
        ofKind elementKind: String,
        at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
        return footerLayoutAttributes
    }

    /// MARK: - Invalidation
    
    override class var invalidationContextClass: AnyClass {
        return LayoutInvalidationContext.self
    }

    override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool {
        guard let collectionView = collectionView else { return false }

        // screen rotation
        if !collectionView.bounds.size.equalTo(newBounds.size) {
            return true
        }
        
        // showing footer
        if newBounds.maxY > contentSize.height {
            return true
        }

        return false
    }
    
    override func invalidationContext(forBoundsChange newBounds: CGRect) -> UICollectionViewLayoutInvalidationContext {
        let invalidationContext = super.invalidationContext(forBoundsChange: newBounds) as! LayoutInvalidationContext
        guard let collectionView = collectionView else { return invalidationContext }

        // if scroll below edge of last cell
        let originChanged = !collectionView.bounds.origin.equalTo(newBounds.origin)
        if originChanged && newBounds.maxY > contentSize.height {
            invalidationContext.invalidateFooter = true
        }
        
        return invalidationContext
    }
    
    override func invalidateLayout(with context: UICollectionViewLayoutInvalidationContext) {
        let invalidationContext = context as! LayoutInvalidationContext
        
        // invalidate after auto-layout changes
        if !invalidationContext.invalidatedSizesForIndexPaths.isEmpty {
            // lowest index path
            let indexPath = invalidationContext.invalidatedSizesForIndexPaths.keys.min { $0 < $1 }
            
            // cells' index paths to reload (indexPath + all below cells)
            let cellsIndexPaths = currentAttributes
                .flatMap { $0 }
                .map { $0.indexPath }
                .filter { $0 >= indexPath! }
            
            prepareContentCellAttributes()
            invalidationContext.invalidateItems(at: cellsIndexPaths)
        }
        
        // invalidate footer after scrolling
        if invalidationContext.invalidateFooter {
            prepareFooterViewAttributes()
            invalidationContext.invalidateDecorationElements(
                ofKind: Constants.Footer.kind,
                at: [Constants.Footer.indexPath]
            )
        }

        super.invalidateLayout(with: invalidationContext)
    }
    
    override func shouldInvalidateLayout(
        forPreferredLayoutAttributes preferredAttributes: UICollectionViewLayoutAttributes,
        withOriginalAttributes originalAttributes: UICollectionViewLayoutAttributes) -> Bool {
        
        // update attributes just for cell (auto-layout)
        if preferredAttributes.representedElementCategory == .cell {
            return preferredAttributes.size != originalAttributes.size
        }
        
        return false
    }
    
    override func invalidationContext(
        forPreferredLayoutAttributes preferredAttributes: UICollectionViewLayoutAttributes,
        withOriginalAttributes originalAttributes: UICollectionViewLayoutAttributes) -> UICollectionViewLayoutInvalidationContext {
        let invalidationContext = super.invalidationContext(
            forPreferredLayoutAttributes: preferredAttributes,
            withOriginalAttributes: originalAttributes) as! LayoutInvalidationContext
        
        // save which cells change size
        invalidationContext.invalidateSize(
            newSize: preferredAttributes.size,
            oldSize: originalAttributes.size,
            forIndexPath: preferredAttributes.indexPath
        )
        
        // cache new cells sizes
        cachedSizes[preferredAttributes.indexPath] = preferredAttributes.size
        return invalidationContext
    }
    
    /// MARK: - Collection View Info
    
    private var contentSize = CGSize.zero
    override var collectionViewContentSize: CGSize {
        return contentSize
    }
    
    /// MARK: - Private
    
    private func registerDecorationView() {
        self.register(EmojiDecorationView.self, forDecorationViewOfKind: Constants.Footer.kind)
    }
}
